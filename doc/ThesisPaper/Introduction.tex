\rchapter{Introduction}

As an interpreted language, Python runs significantly slower than other languages such as C or Fortran. However, code can usually be developed much faster in Python. As a result, it is preferred by many developers for smaller projects. Although the resulting program runs slower, the trade-off is acceptable as the overall time spent on the project is lower.

The situation is more problematic for large projects. In this case, the runtime can be several days. A program written in Python often runs as much as 100 times slower than its equivalent in C or Fortran. This would therefore lead to a runtime of close to one year. This is especially problematic as the simplicity of Python means that many scientists rarely use lower level languages and are thus out of practice when they need to use them.

Multiple solutions exist to try and improve this situation which consists of accelerating Python code so that it runs at speeds which more closely approach those seen in C or Fortran. One type of solution is just-in-time compilers such as PyPy and numba. Pypy is especially powerful as it requires no changes to the code. It can thus adapt the function to the types that are used when it is called, however many packages are not supported and the entire code must be run using pypy. In contrast, numba does not need to be used everywhere, but cannot be used immediately. It requires the types used by the function to be declared in a decorator. This however, means that it can reuse the compiled code making it faster when calls are reused a lot.

Another alternative is to use ahead-of-time compilers such as cython or pythran. Numba also has an ahead-of-time compiler. These tools can be more cumbersome. The type of the arguments must always be given, however they can potentially lead to large speed-ups when used. These tools each work in different ways, for example numba requires only a decorator added to the function which will be compiled. It then compiles the code directly and generates a shared object file. In contrast cython translates the code to C which can then be compiled and called from Python. The advantage of generating code in another language is that it can be compiled with different compilers. It is also possible to modify the resulting code if there are improvements possible which cannot be mimicked in Python. Unfortunately the code generated by cython is rarely human readable so this second advantage is lost.

In this project another ahead-of-time compiler will be used: pyccel. Like cython, Pyccel translates the Python code into another language, in this case Fortran. However, unlike for cython, the code generated by pyccel is human-readable. It is also simple to use, requiring only that a decorator be added to the functions to be translated. Its simplicity, the scale of the speed-up that can be achieved, and the fact that the generated code can be modified to give improve the functions further when required, make pyccel a very useful tool for rapidly developing projects.

The magnitude of the difference in speed between Python and C or Fortran is however so large that it is important to examine the effect that pyccel can have on all aspects of the development of a project in order to determine whether the speed-up achieved is sufficient to allow the development of scientific code in Python. In this project a gyrokinetic plasma simulation is developed in Python. It is then accelerated using pyccel and the resulting program is compared with a Fortran version of the same simulation.

The simulation which will be explored was first developed by Latu et al. \cite{YamanPaper} in their paper Field-Aligned Interpolation for Semi-Lagrangian Gyrokinetic Simulations. In plasma simulations, many points are needed in order to accurately represent all of phase space. This is very costly. As a result many methods have been developed allowing the number of points needed, to be reduced. Gyrokinetic theory allows the problem to be reduced from six dimensions to five (or four for collisionless models). The field-aligned interpolation method explored in the paper by Latu et al. allows fewer points to be used along the toroidal axis

